---
layout: default
comments: true
published: true
title: Analog To Digital Conversion (I<sup>2</sup>C)
---

How can the Raspberry Pi, being an all-digital device, read an analog signal? Use an _Analog-to-Digital Converter (ADC)_. This article discusses why we need those converters, and we focus on I<sup>2</sup>C ADCs.

In the last couple of articles, we discussed Pulse-Width Modulation (PWM), which simulates an analog signal required to dim an LED using a digital output from the Raspberry Pi. But we were not genuinely converted a digital signal to an analog one! We were only producing a high or low value (on/off, 1/0, true/false) for a predefined amount of time (duty cycle), and the analog circuit "believed," by averaging the values, that it was an analog signal. Today we are converting an analog signal to a digital one!

Before going into how this conversion takes place, we need to understand a couple of things.

# Digital Vs. Analog Signals

An _analog signal_ is a continuous signal that represents some physical measurement. Most signals in life (speed, length, weight, brightness, sound, voltage, current, power, resistance, and many more) are analog. For example, think about the speed of a car. A fast car can go from 0 to 60 in few seconds. It does not matter how fast the car is; the speed does not change instantaneously from 0 to 60!

A _digital signal_ represents data as a sequence of different values at any point in time. It can only take one of a fixed number of values depending on the resolution. For example if we have a signal with an 8 bit resolution, then we could obtain 2<sup>8</sup> (256) values ranging from 0x00 (00000000) to 0xFF (11111111). More importantly, those values can change instantaneously!

<p style="text-align:center;">
    <video src="/assets/blog/2021-06-06/Analog-Digital.mov" style="max-width: 100%;" autoplay controls loop></video>
</p>

# Analog-to-Digital Conversion

Computers, like the Raspberry Pi, work with digital signals. If you want to build a system that monitors an analog voltage, you need to use an _Analog-to-Digital Converter_. The ADC converts an analog signal (voltage or current) into a digital number representing the magnitude of the measured value. By the way, a _digital-to-analog converter (DAC)_ performs the reverse function, but we are not discussing those in this article.

There are several factors you need to consider when selecting the correct ADC for your projects, including:

- Interfaces:
  - ADC chips on the Raspberry Pi can use either I<sup>2</sup>C (Inter-Integrated-Circuit) or SPI (Serial Peripheral Interface) bus protocols.
  - This article uses the board provided in the [Frenove kit](https://www.amazon.ca/gp/product/B06W54L7B5/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&psc=1), which uses [ADS7830 ADC chip](https://www.ti.com/lit/ds/symlink/ads7830.pdf?ts=1622913938265), and it uses an I<sup>2</sup>C protocol.
  - SPI is faster than I<sup>2</sup>C, but it limits the number of devices the bus can accept. For the Raspberry Pi, the limit is 2 devices.
  - I<sup>2</sup>C is slower than SPI, but you can connect many more devices (slaves) to the I<sup>2</sup>C master device as long as the slave addresses don't conflict.
- Number of channels:
  - The number of inputs you can connect to the boards.
  - The [ADS7830 ADC chip](https://www.ti.com/lit/ds/symlink/ads7830.pdf?ts=1622913938265) has 8 channels.
- Sensitivity
  - Measured by its bit rate.
  - A higher bit rate means that the chip has a higher resolution for measuring the input voltage, but this comes at the expense of the speed of the readings.
  - The [ADS7830 ADC chip](https://www.ti.com/lit/ds/symlink/ads7830.pdf?ts=1622913938265) has an 8-bit resolution, which means it can have 2<sup>8</sup> (256) values from 0x00 to 0xFF.
- Sample Rate
  - The speed at which the ADC chip can sample and report the input values.
  - The [ADS7830 ADC chip](https://www.ti.com/lit/ds/symlink/ads7830.pdf?ts=1622913938265) has a sampling rate of 70kHz.

The information for the ADS7830 ADC comes from this [datasheet](https://www.ti.com/lit/ds/symlink/ads7830.pdf?ts=1622913938265).

# Project

We are going to build this simple circuit.

![First Phase](/assets/blog/2021-06-06/Project.png)

The potentiometer is going to work as a voltage divider. As we change the resistance value, the voltage detected on pin A0 of the ADS7830 ADC chip changes. The chip converts the value from 0 (representing 0 volts) to 255 (representing 3.3 volts), and the Raspberry Pi receives this value on the SDA (GPIO2) pin. Our code takes that value, displays it on the console and sends it to the class that controls the LED, which we discussed in this article [Hardware-based PWM with RPIO]({% link _posts/2021-05-30-HardwarePWM-RPIO.md %}).

# Voltage Divider

Before moving to the code, we need to understand what we are testing

![Simple series circuit](/assets/blog/2021-06-06/SimpleCircuit.png)

In a series circuit, like the one above, the current is related to the voltage and the total resistance ([Ohm's law](https://en.wikipedia.org/wiki/Ohm%27s_law)). We can calculate the different values with the help of a very well-known triangle.

![VIR](/assets/blog/2021-06-06/VIR.png)

Because this circuit is a series circuit, the total resistance in this circuit is the addition of the two individual resistors (2KΩ + 8KΩ = 10KΩ). We calculate the current by dividing the voltage by the total resistance (3.3 volts / 10KΩ = 330μA). If we keep the total resistance fixed (10KΩ), we can change the values for the resistors (1+9, 2+8, 3+7, or any other value), and the current is going to be the same (330μA).

We are connecting a voltmeter across the second resistor to measure the voltage drop across it. Because the current (330μA) and the value for the second resistor (8KΩ) are known, we can find out what is the value of the voltage dropped across the resistor by multiplying those two values (330μA \* 8KΩ = 2.64 volts).

We are using a 10KΩ potentiometer (variable resistor), which allows us to change the individual resistors' values but keep the total resistor fixed. As you can see in the video below, the voltage dropped changes. In the project we are building, we are going to measure the actual value.

<p style="text-align:center;">
    <video src="/assets/blog/2021-06-06/VoltageDivider.mov" style="max-width: 100%;" autoplay controls loop></video>
</p>

In our project, we are using a potentiometer to change the resistance manually. You could use a thermistor (to find the temperature) or a photoresistor (to find the brightness), or any other components which provide a different resistance under different situations.

# Configure Raspberry Pi

First, we have to configure the Raspberry Pi to enable the I<sup>2</sup>C protocol.

- Type `sudo raspi config` on the terminal window.
- Select `Interfacing Options`.
- Select `I2C`.
- Answer `Yes` when asked to enable I<sup>2</sup>C.
- Close the configuration tool
- Execute this command: `i2cdetect -y 1`

You should see a table like this:

![I2C Table](/assets/blog/2021-06-06/I2C_Table.png)

That is great, I<sup>2</sup>C is working, and we know the address that our ADC is going to use (0x4b).

# Code

Below is the code for the project. Note we are using [RPIO](https://www.npmjs.com/package/rpio) because [PIGPIO](https://www.npmjs.com/package/pigpio) does not support the I<sup>2</sup>C protocol.

<script src="https://gist.github.com/eltoroit/24e03d39671c0dd1f4abe5688facd972.js"></script>

- `1` Import the [RPIO](https://www.npmjs.com/package/rpio) library
- `2` Import the pins library. See the article [GPIO Pins]({% link _posts/2021-04-18-GPIO-pins.md %}) to understand why this is required.
- `4-31` This is the class that we created to use the ADC chip. I have not decided to explain this code just yet, we are covering that in just a little bit. The code is quite complex, and some bizarre things are happening there.
- `33-56` This class is the same we had discussed in the [Hardware-based PWM with RPIO]({% link _posts/2021-05-30-HardwarePWM-RPIO.md %}) article. The only difference is on lines `52-54` where we only want to close RPIO if this is the last usage.
- `58-88` This is the main class for our project. It's responsible for asking for a value from the ADS7830 ADC chip and telling the LED to update itself.
- `90-91` Create an instance of the main class and execute the code.

- `63` Instantiate the ADS7830 class to control the inputs on the ADC chip via the I<sup>2</sup>C protocol.
- `64` Instantiate the LedRPIO class to dim the LED. Please view the [Hardware-based PWM with RPIO]({% link _posts/2021-05-30-HardwarePWM-RPIO.md %}) article for more information.
- `66-77` Controls the graceful termination of the program by shutting down the ADS7830 and the LED when exiting.
- `74-75` Invokes the shutting down of each component, and for the last one, it sends a `true` value to the `isLast` parameter.

- `81-87` Main logic for the project. Reads the value from the ADC and writes the value to the screen and the LED using a 20-millisecond timer.
- `83` Reads the value.
- `84` Updates the LED. Notice that although we measure a voltage (an analog signal from 0 volts to 3.3 volts), the ADC chip provides a digital value between 0 and 255 corresponding to the voltage read.
- `85` Outputs the value read to the screen.

## ADS7830

![Address Byte](/assets/blog/2021-06-06/chip.png)

Let's talk about the elephant in the room: The ADC chip code! The values for the code are only useful if you have the exact same chip I have, but I want to explain where I got my values so that you can use the same code with other chips.

My chip (actually a board) came in the [Freenove Ultimate Starter Kit for Raspberry Pi 4](https://www.amazon.ca/gp/product/B06W54L7B5/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&psc=1) kit I purchased at the beginning of my journey on this fascinating world. It came with a lot of cool stuff, including this little board to do ADC conversions. Freenove mounted an [ADS7830 ADC chip](https://www.ti.com/lit/ds/symlink/ads7830.pdf?ts=1622913938265) from Textas Instruments on a board and added some resistors... They basically converted this surface mount chip into something you can use on your protoboard. But for some reason, when they labeled the pins on the board, they did not use the manufacturer labels, and reading the datasheet can be a bit confusing. I have added next to the pins, the actual labels found in the datasheet, as shown in the image above. Also, important to note that on the board, the pins A0 and A1 are connected to VDD (they have a logical HIGH value).

### Address

- `5` The ADDRESS constant is how we are identifying the actual chip in the I<sup>2</sup>C bus.

Remember, the I<sup>2</sup>C protocol allows you to have many different slaves on the bus as long as they do not have the same address. The address is "burned" into the hardware, but it can be slightly changed. Looking at the [ADS7830 ADC chip](https://www.ti.com/lit/ds/symlink/ads7830.pdf?ts=1622913938265) datasheet, we see this:

![Address Byte](/assets/blog/2021-06-06/AddressByte.png)

The Least significant bit (LSB) of the address byte (8 bits) indicates the operation performed. If we set the (R/<span style="text-decoration:overline">W</span>) bit to 1 then we are reading, setting it to 0 indicates we are writing to the device. So the address is only made of 7 bits, but the first 5 are factory pre-set to 10010. This table shows the possible values we have:

| Factory pre-set |  A1 |  A0 |  Binary |  Hex |
| --------------: | --: | --: | ------: | ---: |
|           10010 |   0 |   0 | 1001000 | 0x48 |
|           10010 |   0 |   1 | 1001001 | 0x49 |
|           10010 |   1 |   0 | 1001010 | 0x4a |
|           10010 |   1 |   1 | 1001011 | 0x4b |

<p></p>

These values can be confirmed by requesting the information from Raspbeery Pi by executing this command: `i2cdetect -y 1`. As shown in the image above, in our case the values for A1 and A0 were set to 1 (3.3 volts).

### Channels

- `6` The CHANNELS is a list of constants that indicate which pin we want to do the ADC conversion

In order to understand where these values are comming from, we need to go back to the datasheet and look at the Command Byte

![Command Byte](/assets/blog/2021-06-06/CommandByte.png)

- **SD**: Would you like to Single-Ended or Differential Inputs?

A typical DAC provides a choice of single-ended or differential analog input channels. **Single-ended Inputs** measure the voltage between the input signal and analog ground. They require only one physical connection per input. **Differential Inputs** measure the voltage difference between two distinct input signals.

We are doing single-ended measurements, so this bit will be set to 1.

- **C2 - C0**:

# OTHER

- [Raspberry Pi SPI and I2C Tutorial](https://learn.sparkfun.com/tutorials/raspberry-pi-spi-and-i2c-tutorial/all)
- [Difference between I2C and SPI ( I2C vs SPI ), you should know.](https://aticleworld.com/difference-between-i2c-and-spi/)
- [Power](https://e2e.ti.com/blogs_/b/process/posts/top-12-ways-to-achieve-low-power-using-the-features-of-an-integrated-adc)
-
